(* IR generation: translate takes a semantically checked AST and
   produces LLVM IR

   LLVM tutorial: Make sure to read the OCaml version of the tutorial

   http://llvm.org/docs/tutorial/index.html

   Detailed documentation on the OCaml LLVM library:

   http://llvm.moe/
   http://llvm.moe/ocaml/

*)

module L = Llvm
module A = Ast
open Sast


type tbl_typ = (string, L.llvalue) Hashtbl.t

(* translate : Sast.program -> Llvm.module *)
let translate (program : sstmt list) : Llvm.llmodule = 

  (* llvm envs *)
  let context    = L.global_context () in
  let the_module = L.create_module context "CHZAP" in

  (* symbol tables *)
  let (globalvars : tbl_typ) = Hashtbl.create 1000 in
  let (localvars : tbl_typ) = Hashtbl.create 1000 in

  (* llvm types *)
  let i32_t      = L.i32_type    context
  and i8_t       = L.i8_type     context
  and f64_t      = L.double_type context (* prob with floats *)
  and void_t     = L.void_type   context
  and char_t     = L.i8_type     context
  and i1_t       = L.i1_type     context
  in

  (* TODO: add more types *)
  let printf_t = L.var_arg_function_type i32_t [| L.pointer_type i8_t |] in
  let printf_func = L.declare_function "printf" printf_t the_module in

  (* return llvm type for sast type *)
  let rec ltype_of_typ = function
    | A.Int   -> i32_t
    | A.Bool  -> i1_t
    | A.Float -> f64_t
    | A.Void -> void_t 
    | A.Char -> char_t
    (* type checks are the job of semantics *)
    | A.Const(t) -> ltype_of_typ t
    | A.Arr(_) -> void_t (*TODO*) 
    | A.Ftyp(_) -> raise (Failure ("TODO"))
    | A.Dyn -> raise (Failure ("TODO"))
  in

  (* Return the address of a variable from symbol table *)
  let addr_of_identifier (s : string)  : L.llvalue = 
    if Hashtbl.mem localvars s then Hashtbl.find localvars s 
    else Hashtbl.find globalvars s
  in

  let add_terminal builder instr =
    match L.block_terminator (L.insertion_block builder) with
    | Some _ -> ()
    | None -> ignore (instr builder) in
  
  (* TODO: fix *)
  let main = L.define_function "main" (L.function_type i32_t (Array.of_list [])) the_module in

  (* Construct code for an expression; return its value *)
  let rec build_expr builder ((_, e) : sexpr) = match e with
    | SIntLit(i)  -> L.const_int i32_t i
    | SBoolLit(b)  -> L.const_int i1_t (if b then 1 else 0)
    | SCharLit(c) -> L.const_int char_t (Char.code c)
    | SFloatLit(f) -> L.const_float f64_t f
    | SArrayLit(l) -> raise (Failure ("TODO"))
    | SId(s)       -> L.build_load (addr_of_identifier s) s builder
    | SBinop(e1, op, e2) ->
      let e1' = build_expr builder e1
      and e2' = build_expr builder e2 in
      (match op with
        A.Add     -> L.build_add
      | A.Sub     -> L.build_sub
      | A.Mul   -> L.build_mul
      | A.Exp      -> L.build_mul (*TODO: fix*)
      | A.Div    -> L.build_sdiv (*TODO: type*)
      | A.Mod    -> L.build_srem
      | A.BWAnd -> L.build_and (*TODO: fix*)
      | A.BWOr -> L.build_or (*TODO: fix*)
      | A.And     -> L.build_and
      | A.Or      -> L.build_or
      | A.Eq   -> L.build_icmp L.Icmp.Eq
      | A.Neq     -> L.build_icmp L.Icmp.Ne
      | A.Less    -> L.build_icmp L.Icmp.Slt
      | A.Leq     -> L.build_icmp L.Icmp.Sle
      | A.Greater -> L.build_icmp L.Icmp.Sgt
      | A.Geq     -> L.build_icmp L.Icmp.Sge
      ) e1' e2' "tmp" builder
    | SUnop(op, e) -> 
      let e' = build_expr builder e in
      (match op with
        A.Not   -> L.build_not
      ) e' "tmp" builder
    | SAssign(var, e) -> 
      let e' = build_expr builder e in
      let v = addr_of_identifier var in
      ignore(L.build_store e' v builder); e'
    | SSubscription(_, _) -> raise (Failure ("TODO"))
    | SCall ("print", [e]) ->
      let int_format_str = L.build_global_stringptr "%d\n" "fmt" builder in
      L.build_call printf_func [| int_format_str ; (build_expr builder e) |]
        "printf" builder
    | SCall (f, args) -> raise (Failure ("TODO"))
      (* let (fdef, fdecl) = StringMap.find f function_decls in
      let llargs = List.rev (List.map (build_expr builder) (List.rev args)) in
      let result = f ^ "_result" in
      L.build_call fdef (Array.of_list llargs) result builder *)
    | SNoexpr -> raise (Failure ("TODO"))
    | SAfunc(t, bl, s) -> raise (Failure ("TODO"))
  in

  (* TODO: fix *)
  let the_function = main in
  (* Build the code for the given statement; return the builder for
    the statement's successor (i.e., the next instruction will be built
    after the one generated by this call) *)
  let rec build_stmt builder = function
    (* allocate var and add address to locals *)
    | SBstmt(Bind(t, n)) -> 
      let local = L.build_alloca (ltype_of_typ t) n builder in
      ignore(Hashtbl.add localvars n local); builder
    | SBAstmt(b, e) -> 
      (* bind and assign *)
      let b = build_stmt builder (SBstmt(b)) in
      ignore(build_expr b (A.Void, e)); builder
    | SBlock(sl) -> build_stmt_list builder sl
    | SExpr(e) -> ignore(build_expr builder e); builder

    | SIf (predicate, then_stmt, else_stmt) ->
      let bool_val = build_expr builder predicate in

      let then_bb = L.append_block context "then" the_function in
      ignore (build_stmt (L.builder_at_end context then_bb) then_stmt);
      let else_bb = L.append_block context "else" the_function in
      ignore (build_stmt (L.builder_at_end context else_bb) else_stmt);

      let end_bb = L.append_block context "if_end" the_function in
      let build_br_end = L.build_br end_bb in (* partial function *)
      add_terminal (L.builder_at_end context then_bb) build_br_end;
      add_terminal (L.builder_at_end context else_bb) build_br_end;

      ignore(L.build_cond_br bool_val then_bb else_bb builder);
      L.builder_at_end context end_bb

    | SFor (e1, e2, e3, body) -> 
      build_stmt builder ( SBlock [e1 ; SWhile (e2, SBlock [body ; SExpr e3]) ] )

    | SWhile (predicate, body) ->
      let while_bb = L.append_block context "while" the_function in
      let build_br_while = L.build_br while_bb in (* partial function *)
      ignore (build_br_while builder);
      let while_builder = L.builder_at_end context while_bb in
      let bool_val = build_expr while_builder predicate in

      let body_bb = L.append_block context "while_body" the_function in
      add_terminal (build_stmt (L.builder_at_end context body_bb) body) build_br_while;

      let end_bb = L.append_block context "while_end" the_function in

      ignore(L.build_cond_br bool_val body_bb end_bb while_builder);
      L.builder_at_end context end_bb

    | SContinue -> raise (Failure ("CodegenError: Continue has not been implemented for codegen"))
    | SBreak -> raise (Failure ("CodegenError: Break has not been implemented for codegen"))
    | SReturn e -> ignore(L.build_ret (build_expr builder e) builder); builder

    | SFunc(b, bl, s) -> raise (Failure ("TODO"))

  and build_stmt_list builder = function
  | [] -> builder
  | s :: sl -> 
    let b = build_stmt builder s in
    build_stmt_list b sl
  in

  (* main block *)
  let builder = L.builder_at_end context (L.entry_block main) in
  let ret = build_stmt_list builder program in
  let _ = add_terminal ret (L.build_ret (L.const_int i32_t 0)) in

  (* return the module *)
  the_module
